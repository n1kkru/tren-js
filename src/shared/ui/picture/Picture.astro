---
import type { ImageMetadata } from 'astro'
import { getImage } from 'astro:assets'

/**
 * Тип описывает один вариант картинки и брейкпоинт,
 * при котором она должна срабатывать.
 */
interface ResponsiveSource {
  /** Метаданные импортированной картинки (import img from '~/assets/...') */
  image: ImageMetadata
  /** Брейкпоинт в пикселях (число или строка, например '768' / '768px') */
  breakpoint: number | string
}

/**
 * Основные пропсы компонента
 */
interface Props {
  /** Массив с перечислением картинок и брейкпоинтов */
  sources?: ResponsiveSource[]
  /** Картинка, которая будет fallback в случае отсутствия поддержки <picture> и основной по умолчанию */
  image: ImageMetadata
  /** Альтернативный текст (обязательно указывать для доступности) */
  alt?: string
  /** Доп. атрибуты для тега \<img\> */
  imgAttributes?: astroHTML.JSX.ImgHTMLAttributes
  /** CSS-класс для внешнего \<picture\> (обёртки) */
  class?: string
}

const {
  sources = [],
  image,
  alt = '',
  imgAttributes,
  class: className,
  ...props
} = Astro.props as Props

/**
 * Функция для извлечения числового значения из breakpoint
 * Позволяет передавать breakpoint как число, так и строку, например "768px".
 */
function getBreakpointValue(bp: number | string): number {
  return typeof bp === 'number' ? bp : parseInt(bp, 10)
}

/**
 * Готовим массив источников (sources).
 * 1. Сортируем по возрастанию, чтобы сначала шли мобильные (маленькие) брейкпоинты,
 *    потом таблет, а в конце десктоп.
 * 2. Для каждого источника заранее генерируем webp- и fallback-формат.
 */
const sortedSources = sources
  // Сортируем по возрастанию, чтобы мелкие экраны были вверху
  .sort((a, b) => getBreakpointValue(a.breakpoint) - getBreakpointValue(b.breakpoint))

// Генерируем для каждого источника оптимизированные изображения
const preparedSources = await Promise.all(
  sortedSources.map(async entry => {
    const { image, breakpoint } = entry

    // Ширину берем из метаданных
    const width = image.width
    // Определяем формат исходника
    const fallbackFormat = image.format

    // Генерируем webp
    const webpResult = await getImage({
      src: image,
      formats: ['webp'],
      widths: [width]
    })
    // Генерируем fallback (исходный формат, например jpg/png/avif и т.д.)
    const fallbackResult = await getImage({
      src: image,
      formats: [fallbackFormat],
      widths: [width]
    })

    return {
      breakpointValue: getBreakpointValue(breakpoint),
      breakpointMedia: `(max-width: ${getBreakpointValue(breakpoint)}px)`,
      webp: webpResult.srcSet.attribute,
      fallback: fallbackResult.srcSet.attribute,
      fallbackFormat
    }
  })
)

/**
 * Аналогично обрабатываем fallbackImage — это наша "основная" картинка (без media).
 */
const fallbackImageWidth = image.width
const fallbackImageHeight = image.height
const fallbackImageFormat = image.format

const fallbackWebp = await getImage({
  src: image,
  formats: ['webp'],
  widths: [fallbackImageWidth]
})
const fallbackImg = await getImage({
  src: image,
  formats: [fallbackImageFormat],
  widths: [fallbackImageWidth]
})

export { Picture }
---

<picture
  class:list={['picture', className]}
  {...props}
>
  {/* Перебираем каждый источник и рендерим <source> для webp и fallback формата */}
  {
    preparedSources.map(srcObj => (
      <>
        <source
          media={srcObj.breakpointMedia}
          type="image/webp"
          srcset={srcObj.webp}
        />
        <source
          media={srcObj.breakpointMedia}
          type={`image/${srcObj.fallbackFormat}`}
          srcset={srcObj.fallback}
        />
      </>
    ))
  }

  {/* Без media-условия: "дефолтный" webp для всех устройств, если ничего не подошло выше */}
  <source
    type="image/webp"
    srcset={fallbackWebp.srcSet.attribute}
  />

  {/* Дефолтный fallback (например jpg) */}
  <source
    type={`image/${fallbackImageFormat}`}
    srcset={fallbackImg.srcSet.attribute}
  />

  {/* Fallback-картинка в <img> на случай, если браузер не поддерживает <picture> */}
  <img
    src={fallbackImg.src}
    alt={alt}
    width={fallbackImageWidth}
    height={fallbackImageHeight}
    loading="lazy"
    decoding="async"
    class:list={['picture__img', imgAttributes?.class]}
    {...imgAttributes}
  />
</picture>

<style>
  @import './index.scss';
</style>
