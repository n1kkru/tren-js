---
import type { ImageMetadata } from 'astro'
import { getImage } from 'astro:assets'
import type { ResponsiveSource } from './picture.types'

/**
 * Пропсы компонента <Picture>
 */
interface Props {
  /**
   * Массив адаптивных источников: разные изображения для разных брейкпоинтов
   * Если не указан — будет использоваться только основное изображение
   */
  sources?: ResponsiveSource[]

  /**
   * Основное изображение (используется как fallback и дефолтное)
   */
  image: ImageMetadata // This is the main image prop

  /**
   * Альтернативный текст для тега <img>
   * Обязателен для доступности (a11y), но по дефолту — пустая строка
   */
  alt?: string

  /**
   * Дополнительные атрибуты тега <img>
   */
  imgAttributes?: astroHTML.JSX.ImgHTMLAttributes

  /**
   * CSS-класс, применяемый к <picture>
   */
  class?: string

  /**
   * Атрибут sizes для <source> и <img>
   * Управляет, какие версии изображений использовать при разных условиях ширины
   * По умолчанию — '100vw'
   */
  sizes?: string

  /**
   * Качество изображений (0–100), влияет на степень сжатия
   * По умолчанию — 75
   */
  quality?: number
}

// Деструктуризация пропсов
const {
  sources = [],
  image: mainImageMetadata, // Renamed to avoid confusion with 'image' in map
  alt = '',
  imgAttributes,
  class: className,
  sizes = '100vw',
  quality = 75,
  ...props
} = Astro.props as Props

/**
 * Преобразует breakpoint из строки в число (если нужно)
 */
function getBreakpointValue(bp: number | string): number {
  return typeof bp === 'number' ? bp : parseInt(bp, 10)
}

// Сортируем источники по возрастанию брейкпоинта
const sortedSources = sources.sort(
  (a, b) => getBreakpointValue(a.breakpoint) - getBreakpointValue(b.breakpoint)
)

// Для каждого источника — генерируем webp и используем raw .src для fallback-формата
const preparedSources = await Promise.all(
  sortedSources.map(async ({ image: responsiveImage, breakpoint }) => {
    // 'image' here is the ImageMetadata for the current responsive source
    const width = responsiveImage.width
    const originalFormat = responsiveImage.format

    // Generate WebP version
    const webp = await getImage({
      src: responsiveImage,
      formats: ['webp'],
      widths: [width],
      quality
    })

    // For the original format fallback, use the direct .src
    // The .src from an import is already an optimized path from Astro
    const fallbackSrcSet = responsiveImage.src

    return {
      media: `(max-width: ${getBreakpointValue(breakpoint)}px)`,
      webpSrcSet: webp.srcSet.attribute,
      fallbackSrcSet: fallbackSrcSet, // Uses direct .src
      fallbackFormat: originalFormat
    }
  })
)

// Обработка fallback-изображения (дефолтный вариант)
const fallbackWidth = mainImageMetadata.width
const fallbackHeight = mainImageMetadata.height
const mainImageOriginalFormat = mainImageMetadata.format

// WEBP для основной картинки
const fallbackWebp = await getImage({
  src: mainImageMetadata,
  formats: ['webp'],
  widths: [fallbackWidth],
  quality
})

// For the main image's original format fallback <source> and <img>, use its direct .src
const mainImageFallbackSrc = mainImageMetadata.src
---

<picture
  class:list={['picture', className]}
  {...props}
>
  {
    preparedSources.map(source => (
      <>
        <source
          media={source.media}
          type="image/webp"
          srcset={source.webpSrcSet}
          sizes={sizes}
        />
        {/* Fallback обходит getImage() */}
        <source
          media={source.media}
          type={`image/${source.fallbackFormat}`}
          srcset={source.fallbackSrcSet}
          sizes={sizes}
        />
      </>
    ))
  }

  {/* WebP source */}
  <source
    type="image/webp"
    srcset={fallbackWebp.srcSet.attribute}
    sizes={sizes}
  />
  {/* Оригинальный формат если .webp откзывает, обход getImage() */}
  <source
    type={`image/${mainImageOriginalFormat}`}
    srcset={mainImageFallbackSrc}
    sizes={sizes}
  />

  {/* в случае отказа обоих source */}
  <img
    src={mainImageFallbackSrc}
    alt={alt}
    width={fallbackWidth}
    height={fallbackHeight}
    loading="lazy"
    class:list={['picture__img', imgAttributes?.class]}
    {...imgAttributes}
    sizes={sizes}
  />
</picture>

<style>
  @import './picture.scss';
</style>
