---
import type { ImageMetadata } from 'astro'
import { getImage } from 'astro:assets'

/**
 * Описание картинки и брейкпоинта, при котором она должна подставляться
 */
interface ResponsiveSource {
  /** Импортированная картинка (через import из '~/assets/...') */
  image: ImageMetadata
  /** Брейкпоинт (например, 768 или '768px'), на котором сработает эта версия */
  breakpoint: number | string
}

/**
 * Пропсы компонента <Picture>
 */
interface Props {
  /**
   * Массив адаптивных источников: разные изображения для разных брейкпоинтов
   * Если не указан — будет использоваться только основное изображение
   */
  sources?: ResponsiveSource[]

  /**
   * Основное изображение (используется как fallback и дефолтное)
   */
  image: ImageMetadata

  /**
   * Альтернативный текст для тега <img>
   * Обязателен для доступности (a11y), но по дефолту — пустая строка
   */
  alt?: string

  /**
   * Дополнительные атрибуты тега <img>
   */
  imgAttributes?: astroHTML.JSX.ImgHTMLAttributes

  /**
   * CSS-класс, применяемый к <picture>
   */
  class?: string

  /**
   * Атрибут sizes для <source> и <img>
   * Управляет, какие версии изображений использовать при разных условиях ширины
   * По умолчанию — '100vw'
   */
  sizes?: string

  /**
   * Качество изображений (0–100), влияет на степень сжатия
   * По умолчанию — 75
   */
  quality?: number
}

// Деструктуризация пропсов
const {
  sources = [],
  image,
  alt = '',
  imgAttributes,
  class: className,
  sizes = '100vw',
  quality = 75,
  ...props
} = Astro.props as Props

/**
 * Преобразует breakpoint из строки в число (если нужно)
 */
function getBreakpointValue(bp: number | string): number {
  return typeof bp === 'number' ? bp : parseInt(bp, 10)
}

// Сортируем источники по возрастанию брейкпоинта
const sortedSources = sources.sort(
  (a, b) => getBreakpointValue(a.breakpoint) - getBreakpointValue(b.breakpoint)
)

// Для каждого источника — генерируем webp и fallback-форматы
const preparedSources = await Promise.all(
  sortedSources.map(async ({ image, breakpoint }) => {
    const width = image.width
    const fallbackFormat = image.format

    const webp = await getImage({
      src: image,
      formats: ['webp'],
      widths: [width],
      quality
    })

    const fallback = await getImage({
      src: image,
      formats: [fallbackFormat],
      widths: [width],
      quality
    })

    return {
      media: `(max-width: ${getBreakpointValue(breakpoint)}px)`,
      webpSrcSet: webp.srcSet.attribute,
      fallbackSrcSet: fallback.srcSet.attribute,
      fallbackFormat
    }
  })
)

// Обработка fallback-изображения (дефолтный вариант)
const fallbackWidth = image.width
const fallbackHeight = image.height
const fallbackFormat = image.format

const fallbackWebp = await getImage({
  src: image,
  formats: ['webp'],
  widths: [fallbackWidth],
  quality
})

const fallbackImg = await getImage({
  src: image,
  formats: [fallbackFormat],
  widths: [fallbackWidth],
  quality
})
---

<picture
  class:list={['picture', className]}
  {...props}
>
  {
    preparedSources.map(source => (
      <>
        <source
          media={source.media}
          type="image/webp"
          srcset={source.webpSrcSet}
          sizes={sizes}
        />
        <source
          media={source.media}
          type={`image/${source.fallbackFormat}`}
          srcset={source.fallbackSrcSet}
          sizes={sizes}
        />
      </>
    ))
  }

  <source
    type="image/webp"
    srcset={fallbackWebp.srcSet.attribute}
    sizes={sizes}
  />
  <source
    type={`image/${fallbackFormat}`}
    srcset={fallbackImg.srcSet.attribute}
    sizes={sizes}
  />

  <img
    src={fallbackImg.src}
    alt={alt}
    width={fallbackWidth}
    height={fallbackHeight}
    loading="lazy"
    decoding="async"
    class:list={['picture__img', imgAttributes?.class]}
    {...imgAttributes}
    sizes={sizes}
  />
</picture>

<style>
  @import './index.scss';
</style>
